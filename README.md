# DSA-with-JAVA
This Repo contains all important DSA Topics

DATA STRUCTURES AND ALGORITHMS COVERING

BIG O NOTATION , TIME COMPLEXITY AND SPACE COMPLEXITY

**SINGLY LINKED LIST**

--> DISPLAY THE ELEMENTS OF THE LINKED LIST

--> PRINT THE LENGTH OF THE LINKED LIST

--> INSERT THE ELEMENT AT THE FIRST OF THE LINKED LIST

--> INSERT THE ELEMENT AT THE LAST OF THE LINKED LIST

--> INSERT THE ELEMENT AT A PARTICULAR POSITION

--> DELETE FIRST ELEMENT OF THE LINKEDLIST

--> DELETE LAST ELEMENT OF THE LINKED LIST

--> DELETE NODE AT A PARTICULAR POSITION

--> SEARCH A PARTICULAR ELEMENT IN THE LINKED LIST

--> FIND MIDDLE NODE OF THE LINKED LIST

--> GET N'TH NODE FROM THE END OF THE LINKED LIST

--> REMOVE N'TH NODE FROM THE END OF THE LINKED LIST

--> REMOVE DUPLICATES IN THE LINKED LIST

--> INSERT NODE IN SORTED LINKED LIST

--> DETECT LOOP IN A LINKED LIST

--> CREATING A LOOP IN THE LINKED LIST

--> REMOVE KEY IN THE LINKED LIST

--> REVERSE THE LINKED LIST

--> FIND START OF THE LOOP IN THE LINKED LIST

--> REMOVE LOOP FROM THE LINKED LIST

--> MERGE TWO SORTED LINKED LISTS

--> ADD TWO NUMBERS IN THE LINKED LIST

--> PALINDROME LINKED LIST [X]

--> CLONE A LINKED LIST WITH NEXT AND RANDOM POINTER [X]

**DOUBLY LINKED LIST**

--> PRINT ELEMENTS OF A DOUBLY LINKED LIST

--> INSERT NODE AT THE BEGINNING OF DOUBLY LINKED LIST

--> INSERT NODE AT THE LAST OF DOUBLY LINKED LIST

--> DISPLAY DOUBLY LINKED LIST IN FORWARD DIRECTION

--> DISPLAY DOUBLY LINKED LIST IN BACKWARD DIRECTION

--> DELETE FIRST NODE IN A DOUBLY LINKED LIST

--> DELETE LAST NODE IN A DOUBLY LINKED LIST

--> FLATTENING A MULTILEVEL DOUBLY LINKED LIST [X]

**CIRCULAR LINKED LIST**

--> IMPLEMENTATION OF CIRCULAR LINKED LIST

--> TRAVERSE AND PRINT A CIRCULAR SINGLY LINKED LIST

--> INSERT NODE AT THE START OF THE CIRCULAR SINGLY LINKED LIST

--> INSERT NODE AT THE END OF THE CIRCULAR SINGLY LINKED LIST

--> REMOVE FIRST NODE OF THE CIRCULAR SINGLY LINKED LIST

**ARRAYS**

--> DECLARATION AND INITIALIZATION OF 1D ARRAY

--> ADDING OR UPDATING ELEMENTS IN 1D ARRAY

--> PRINT ELEMENTS OF AN ARRAY

--> REMOVE EVEN INTEGERS FROM AN ARRAY

--> REVERSE AN ARRAY

--> FIND MINIMUM VALUE IN ARRAY

--> FIND SECOND MAXIMUM VALUE IN ARRAY

--> MOVE ZEROES TO END OF AN ARRAY

--> RESIZE AN ARRAY

--> MISSING NUMBER IN ARRAY

**STACKS**

--> IMPLEMENTATION OF STACK USING LINKED LIST

--> REVERSE A STRING USING STACK

--> IMPLEMENTATION OF STACK USING ARRAYS

--> FINDING NEXT GREATER ELEMENTS IN ARRAY USING STACK

--> VALID PARENTHESES PROBLEM USING STACK

--> IMPLEMENT STACK USING TWO QUEUE [X]

--> INFIX TO POSTFIX CONVERSION USING STACK [X]

**QUEUES**

--> IMPLEMENT QUEUE USING LINKED LIST

--> IMPLEMENT QUEUE USING TWO STACK [X]

--> CIRCULAR QUEUE IMPLEMENTATION USING ARRAY [X]

--> GENERATE BINARY NUMBERS IN QUEUE [X]

**TREES**

--> IMPLEMENTATION OF BINARY TREE

--> RECURSIVE (PREORDER,INORDER,POSTORDER) TRAVERSAL OF A BINARY TREE

--> ITERATIVE (PREORDER,INORDER,POSTORDER) TRAVERSAL OF A BINARY TREE

--> HEIGHT OF A BINARY TREE [X]

--> SIZE OF A BINARY TREE [X]

--> LEFT VIEW OF A BINARY TREE [X]

--> TOP VIEW OF A BINARY TREE [X]

--> FLATTEN BINARY TREE TO DOUBLY LINKED LIST [X]

--> DIAMETER OF A BINARY TREE [X]

--> LOWEST COMMON ANCESTOR IN A BINARY TREE [X]

--> BURN A TREE | MINIMUM TIME TO BURN A TREE [X]

--> MAXIMUM VALUE OF A BINARY TREE [X]

--> VERTICAL ORDER TRAVERSAL OF A BINARY TREE [X]

--> HOW TO INVERT A BINARY TREE [X]

**BINARY SEARCH TREE**

--> REPRESENTING ,INSERTING VALUE AND VALIDATING BINARY SEARCH TREE

--> DELETE A NODE IN BINARY SEARCH TREE [X]

--> FIND THE FLOOR AND CEIL VALUE IN BINARY SEARCH TREE [X]

--> TWO SUM IN BINARY SEARCH TREE [X]

**HEAP**

--> REPRESENT BINARY HEAP USING PRIORITY QUEUE

--> BOTTOM-UP REHEAPIFY(SWIM) AND TOP-DOWN REHEAPIFY(SINK)

--> INSERT IN A MAX HEAP

--> DELETE MAX ELEMENT IN A MAX HEAP

**MATRIX**

--> SEARCH IN A ROW AND COLUMN WISE SORTED MATRIX

--> PRINT A GIVEN MATRIX IN SPIRAL FORM
